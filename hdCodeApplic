--[[ 
	Custom Module for my game's M1 System
	Handles the basic melee combo (M1s), cooldowns, hit detection, knockbacks, etc.
	Most systems and services are custom-made.
--]]

-- Get Roblox services used in this module
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Remotes used for replicating combat actions to clients
local Remotes = ReplicatedStorage.Events.Remotes
local CombatActionRemote = Remotes.CombatActionRemote
local ReplicateRemote = Remotes.ReplicateRemote

-- Grab the main module folders
local Modules = ReplicatedStorage.Modules
local Managers = Modules.Managers

-- Require managers and services that handle different systems
local AnimationManager = require(Managers.AnimationManager) -- handles animations loading/playing
local SoundManager = require(Managers.Sound) -- handles combat sound playback
local StateManager = require(Managers.StateManager) -- manages char states
local CombatServices = require(ServerStorage.Modules.Services.CombatServices.CombatServices)
local OtherServices = require(Modules.SharedServices.OtherServices)

-- Assets (animations, sounds, etc.)
local Assets = ReplicatedStorage.Assets
local Animations = Assets.Animations
local Default = Animations.Default
local M1Animations = Default.M1s -- M1 animation folder

-- Keep track of M1 reset loops per character
local M1ResetLoops = {}

-- Module table
local module = {}

-- Get individual services from CombatServices system
local StateService = CombatServices.GetService("StateService") -- for managing temporary states
local DebounceService = CombatServices.GetService("DebounceService") -- prevents spammy input
local CooldownService = CombatServices.GetService("CooldownService") -- for global/internal cooldowns
local MovementService = CombatServices.GetService("MovementService") -- temporarily change walk speed/jump
local CharacterStates = CombatServices.GetService("CharacterStates") -- checks if chars are valid/alive
local HitBoxService = CombatServices.GetService("HitBoxService") -- handles hit detection logic

-- Starts a timed loop that resets the M1 combo index after no hits for X seconds
local function StartM1ResetLoop(character)
	if not character or not character.Parent then return end
	if M1ResetLoops[character] then return end -- skip if already running

	local resetTime = module.M1Settings.M1ResetTimer
	local lastCheck = os.clock()
	local connection

	-- Every frame check if the player waited too long to continue their combo
	connection = RunService.Heartbeat:Connect(function()
		if not character or not character.Parent then 
			connection:Disconnect()
			M1ResetLoops[character] = nil
			return 
		end

		local lastM1 = StateManager.GetState(character, "LastM1") or 0
		-- if player didn’t hit again for too long, reset combo index to 1
		if os.clock() - lastM1 >= resetTime then
			StateService:AddStates({ Char = character, States = { MIndex = 1 } })
			connection:Disconnect()
			M1ResetLoops[character] = nil
		end
	end)

	M1ResetLoops[character] = connection
end

-- Decides how much damage and knockback a specific M1 swing deals
local function GetDamageAndKnockback(m1Type, currentMeleeIndex, humanoidRootPart)
	local damageAmount
	local knockback

	-- Special case: Downslam final hit
	if m1Type == "DownSlam" and currentMeleeIndex == 4 then
		damageAmount = module.M1Settings.Damages.DownSlam
		knockback = {
			KnockbackType = "Velocity",
			MaxForce = Vector3.new(2000000000, 20000000, 20000000),
			Velocity = Vector3.new(0, -10, 0),
			Time = 0.35
		}

	-- Special case: Uppercut final hit
	elseif m1Type == "UpperCut" and currentMeleeIndex == 4 then
		damageAmount = module.M1Settings.Damages.UpperCut
		knockback = {
			KnockbackType = "Velocity",
			MaxForce = Vector3.new(2000000000, 20000000, 20000000),
			Velocity = Vector3.new(0, 27, 0),
			Time = 0.35
		}

	-- Normal fourth hit — stronger push forward
	elseif m1Type == "Normal" and currentMeleeIndex == 4 then
		damageAmount = module.M1Settings.Damages[4]
		knockback = {
			KnockbackType = "Velocity",
			MaxForce = Vector3.new(30000000, 15000000, 30000000),
			Velocity = humanoidRootPart.CFrame.LookVector * 45,
			Time = 0.4
		}

	-- Otherwise, default to a small push forward
	else
		damageAmount = module.M1Settings.Damages[currentMeleeIndex]
		knockback = {
			KnockbackType = "Velocity",
			MaxForce = Vector3.new(30000000, 15000000, 30000000),
			Velocity = humanoidRootPart.CFrame.LookVector * 3,
			Time = 0.1
		}
	end

	return damageAmount, knockback
end

-- Base settings for M1 system (combo damage, stun times, etc.)
module.M1Settings = {
	CdType = "M1", -- cooldown type id
	DefaultM1WalkSpeed = 10,
	M1EndWalkSpeed = 2,
	M1ResetTimer = 2, -- reset combo after 2s
	M1DebounceDuration = 0.35, -- debounce for normal swings
	M1EndDebounceDuration = 0.4, -- debounce for last swing
	M1EndDelay = 2.5, -- cooldown before next combo
	JumpsDisabledTime = { [1] = 0.6, [2] = 0.6, [3] = 0.6, [4] = 0.6 },
	EnemyStuns = { Normal = 0.6, DownSlam = 2, UpperCut = 2, FourthM1 = 2 },
	BlockedPunish = { [1] = .2, [2] = .2, [3] = .3, [4] = .4 },
	IgnoreBlock = { Normal = true, UpperCut = true, DownSlam = false },
	Damages = { [1] = 2, [2] = 2, [3] = 2, [4] = 3.5, UpperCut = 3.5, DownSlam = 3.5 },
	M1Size = { Normal = Vector3.new(4, 3, 4), DownSlam = Vector3.new(4, 4, 4), UpperCut = Vector3.new(4, 4, 4) },
	M1OffSets = { Normal = CFrame.new(0, 2, -4), DownSlam = CFrame.new(0, -2, -4), UpperCut = CFrame.new(0, 0, -4) }
}

-- Only these attack types are valid
local ValidM1Types = { Normal = true, DownSlam = true, UpperCut = true }

-- Gets the player from a character model safely
local function GetPlayerFromCharacter(character)
	if not character or not character:IsA("Model") then return nil end
	return game.Players:GetPlayerFromCharacter(character)
end

-- Main M1 attack logic
function module.M1(character, data)
	if type(data) ~= "table" or not character or not character:IsA("Model") then return end
	if DebounceService:HasDebounce({ Char = character }) then return end
	if not CharacterStates:IsCharValid({ Char = character, ShouldBeAlive = true, NotStunned = true }) then return end

	local currentMeleeIndex = tonumber(StateService:GetState({ Char = character, State = "MIndex" }) or 1)

	-- Change walk speed and cooldown depending on which hit of combo we’re on
	local walkSpeed, debounceDuration, cooldownDuration
	if currentMeleeIndex < 4 then
		walkSpeed = module.M1Settings.DefaultM1WalkSpeed
		debounceDuration = module.M1Settings.M1DebounceDuration
		cooldownDuration = module.M1Settings.M1DebounceDuration
	else
		walkSpeed = module.M1Settings.M1EndWalkSpeed
		debounceDuration = module.M1Settings.M1EndDebounceDuration
		cooldownDuration = module.M1Settings.M1EndDelay
	end

	-- Prevent spam by checking if M1 is on cooldown
	if not CooldownService:NotOnCooldownThenSetCooldown({ Char = character, CDType = module.M1Settings.CdType, Value = cooldownDuration }) then
		return
	end

	StateService:SetCurrentAction({ Char = character, Action = "M1" })

	-- figure out which M1 type to use
	local m1Type = type(data.M1Type) == "string" and data.M1Type or "Normal"
	if not ValidM1Types[m1Type] then m1Type = "Normal" end

	-- store timestamp for M1 reset loop
	StateManager.SetState(character, "LastM1", os.clock())
	StartM1ResetLoop(character)

	-- choose animation based on combo index and type
	local punchAnimation
	if m1Type == "UpperCut" and currentMeleeIndex == 4 then
		punchAnimation = M1Animations.UpperCut
	elseif m1Type == "DownSlam" and currentMeleeIndex == 4 then
		punchAnimation = M1Animations.DownSlam
	else
		punchAnimation = M1Animations["Melee" .. currentMeleeIndex]
	end

	local Conns = {}
	local CleanUpTable = {}

	-- play the actual animation
	local punchTrack = AnimationManager.LoadAnim(character, "M1", punchAnimation)
	Conns.PunchTrackStart = punchTrack:Play()
	table.insert(CleanUpTable,punchTrack)

	-- when the swing starts, replicate swing visuals to everyone
	Conns.SwingReg = punchTrack:GetMarkerReachedSignal("swingreg"):Connect(function()
		ReplicateRemote:FireAllClients({
			Char = character,
			ActionType = "M1",
			Function = "Start",
			M1Function = "SwingReplicate",
			M1Type = "Default",
			M1Track = m1Type,
			M1Index = currentMeleeIndex
		})
	end)

	local hitLanded = false

	-- when the hit marker triggers, create the hitbox and apply damage
	Conns.HitReg = punchTrack:GetMarkerReachedSignal("hitreg"):Connect(function()
		local nextIndex = currentMeleeIndex + 1
		if nextIndex > 4 then nextIndex = 1 end
		StateService:AddStates({ Char = character, States = { MIndex = nextIndex } })

		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if not humanoidRootPart then return end

		-- create hitbox and define callback for when it hits someone
		HitBoxService.CreateHitbox({
			Caster = character,
			Origin = humanoidRootPart,
			Size = module.M1Settings.M1Size[m1Type],
			Offset = module.M1Settings.M1OffSets[m1Type],
			HitboxType = "Box",
			HitType = "OneHit",
			TickInterval = 0.25,
			DelayTime = 0,
			Debris = 0.1,
			IgnoreBlock = module.M1Settings.IgnoreBlock[m1Type],
		}, function(targetCharacter)
			local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
			if not targetHumanoid then return end

			-- make sure target is valid enemy
			if not CharacterStates:IsEnemyValid({
				EnemyChar = targetCharacter,
				Attacker = character,
				StunForDodgeOnThisAttack = 0.5,
				BlockedPunish = module.M1Settings.BlockedPunish[currentMeleeIndex],
				IgnoresDead = true,
				IgnoresRagdoll = true
			}) then return end

			hitLanded = true

			-- replicate hit effect to everyone
			ReplicateRemote:FireAllClients({
				Char = character,
				Enemy = targetCharacter,
				ActionType = "M1",
				Function = "Start",
				M1Function = "HitReplicate",
				M1Type = "Default",
				M1Track = m1Type,
				M1Index = currentMeleeIndex
			})

			-- calculate damage and knockback
			local damageAmount, knockback = GetDamageAndKnockback(m1Type, currentMeleeIndex, humanoidRootPart)
			local stunDuration = (currentMeleeIndex == 4) and 2 or module.M1Settings.EnemyStuns[m1Type]
			local ragdollData = (currentMeleeIndex == 4) and { Time = module.M1Settings.EnemyStuns.FourthM1 } or nil

			-- actually apply damage using service
			CombatServices.GetService("DamageService"):Damage({
				Character = character,
				Enemy = targetCharacter,
				Damage = damageAmount,
				StateData = { Stunned = stunDuration },
				MovementData = { WalkSpeed = 1, JumpPower = 0, Time = module.M1Settings.EnemyStuns[m1Type] },
				RagdollData = ragdollData,
				KnockbackData = knockback,
				CharacterKnockbackData = {
					KnockbackType = "Velocity",
					MaxForce = Vector3.new(30000000, 15000000, 30000000),
					Velocity = humanoidRootPart.CFrame.LookVector * 10,
					Time = 0.1
				}
			})
		end)
	end)

	-- apply movement limit + debounce for attack duration
	local finalDebounce = debounceDuration
	Conns.Debounce = DebounceService:SetDebounce({ Char = character, Toggle = true, Duration = finalDebounce })
	Conns.MovementAdd = MovementService:AddMovements({
		Char = character,
		Movements = { WalkSpeed = walkSpeed, JumpHeight = 0 },
		Time = module.M1Settings.JumpsDisabledTime[currentMeleeIndex]
	})

	-- handles when player gets interrupted mid-attack
	OtherServices.GetService("InterruptionHandler"):HandleInterruption({
		Char = character,
		ConnsTable = Conns,
		CleanUpTable = CleanUpTable
	})
end

return module
